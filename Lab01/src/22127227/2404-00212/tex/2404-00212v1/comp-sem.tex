\section{Computational semantics of \texorpdfstring{\pcfc{}}{pcf/cost}}\label{sec:comp-sem}

Computational adequacy is a property relating the denotational semantics of a language with its execution behavior as given by an \emph{operational semantics}. Commonly one employs a \emph{structural operational semantics}~\cite{plotkin:2004} in which the operational semantics of a language is defined as an inductive family of relations ${\mapsto_A} \subseteq A \times A$. Both termination and evaluation can be defined by means of the reflexive transitive closure of the family of relations $\mapsto_A$, which is the smallest reflexive, transitive family of relations containing $\mapsto_A$. 

\emph{Computational semantics.} We consider an alternative formulation of the dynamic semantics of \pcfc{} in which execution is modeled not as an inductive family but directly as a (partial) computation. This departure from traditional operational semantics is necessitated by our proof of computational adequacy. As we explain in \cref{subsec:adequacy}, termination must be a $\Sigma$-decidable predicate; however, the reflexive-transitive closure of a decidable relation (such as $\mapsto_A$) can only be seen to be a $\Sigma$-predicate assuming that $\Sigma$ is closed under countable joins of decidable propositions that are \emph{preserved} by the inclusion into the ambient type theory, \ie{} $\some{n:\Nat} \phi(n) \in \Sigma$ for every countable family of $\Sigma$-propositions $\phi$. Our approach bypasses this question by de-emphasizing $\Nat$ in favor of the initial lifting algebra $\omega$, a lesson of Simpson~\cite{simpson:2004}. 
We discuss the relationship between this computational semantics and ordinary operational semantics in \cref{sec:conclusion}. 

\subsection{Computational semantics of \texorpdfstring{\pcfc{}}{pcf/cost}}\label{subsec:comp-sem}

We begin with a family of small-step transition relations \({ \mapsto_A }  \subseteq   \tmv{A}  \times   \mathbb{C}   \times   \tmv{A}\) that implements the \emph{cost effect} model in the sense of Hoffmann~\cite{hoffmann:2019:cost-sem}. The intuitive meaning of \(e  \mapsto  c, e'\) is that \(e\) transitions in one step to \(e'\) and incurs cost \(c\); the only place where cost is effected is at \(\mathsf{step}\): $\mathsf{step} ^c(e)  \mapsto  c, e$. The rest of the rules defining this relation are the standard rules for a call-by-push-value language; we defer to Levy~\cite{levy:2003:book} for a detailed account. We iterate the ``one step'' relation to obtain the partial map implementing the computational semantics. Because $\mapsto_A$ is decidable, we have a characteristic map $\kw{out}  :  \impl{A :  \mathsf{tp} ^+ }.~\tmv{A}  \to  1 + (\mathbb{C}  \times \tmv{A})$. Consider the following functional: 
\[
  \begin{aligned}    
    \Phi _{ \mathsf{eval} }~f~(e, v) =  \begin{cases}   c  \boxplus  f(e', v)
       & \mathsf{out} (e) =  \mathsf{inr}   \cdot  (c, e')  \\   (e = v,  \lambda  -.~0) 
       &  \mathsf{out} (e) =  \mathsf{inl}   \cdot   \star  
      \end{cases} 
  \end{aligned}\]
Define \(\mathsf{eval} : \impl{A :  \mathsf{tp} ^+}.~\tmv{A} \times \tmv{A} \to \kw{T}(1)\) to be the fixed-point of \(\Phi _{ \mathsf{eval} }\) and \(\mathsf{profile}  :  \mathsf{tm} ^+( \mathsf{U} \mathsf{F} 1 )   \to   \mathsf{T} (1)\) as \(\mathsf{profile} (e) =  \mathsf{eval} (e,  \mathsf{ret} ( \star ))\). The meaning of $\kw{eval}_A(e, v) : \kw{T}(1)$ is that when it is defined, $e$ computes to a value $v$ incurring the defined cost. Similarly, $\kw{profile}(e)$ is the cost of computing $e$ when the former is defined. In the following, we will establish some expected properties of the computational semantics such as the uniqueness of evaluation and a ``big-step'' law for sequencing evaluations. 

\begin{restatable}{proposition}{PropEvalFunc}\label[prop]{prop:eval-func}
  The relation $\supp(-) \circ \kw{eval}$ is functional.
\end{restatable}

\begin{restatable}{proposition}{PropEvalSeq}\label[prop]{prop:eval-seq}
  If \(\kw{eval} (e,  \kw{ret} (v)) = c_1\) and \(\kw{eval} (g~v,  \kw{ret} (w)) = c_2\), then \(\mathsf{eval} (e; g,  \kw{ret} (w)) = c_1 + c_2\). 
\end{restatable}

\begin{corollary}\label[cor]{prop:prof-seq}
If \(\mathsf{eval} (e,  \mathsf{ret} (v)) = c_1\) and \(\mathsf{profile} (g~v) = c_2\), then \(\mathsf{profile} (e; g) = c_1 + c_2\). 
\end{corollary}

In ordinary operational semantics, one has the property that $e; g \Downarrow v$ implies there exists a value $w$ such that $e \Downarrow w$ and $g(w) \Downarrow v$. An analogous rule also holds for the computational semantics, except the value $w$ is not existentially quantified: 

\begin{restatable}{proposition}{PropCompIndSeq}\label[prop]{prop:comp-ind-seq}
  The following inference rule is valid for any $\Sigma$-predicate $\varphi$: 
  \begin{mathpar}
    \inferrule{
      \all{v : A} \kw{eval}(e, v)\supp{} \land \kw{eval}(g~v, \kw{ret}(w))\supp{} \to \varphi(\kw{eval}(e, v) + \kw{eval}(g~v, \kw{ret}(w)))
    }{
      \kw{eval}(e; g, \kw{ret}(w))\supp{} \to \varphi(\kw{eval}(e; g, \kw{ret}(w)))
    }
   \end{mathpar}
\end{restatable}

Using this rule we may derive the following law for profiling compound sequences: 

\begin{restatable}{proposition}{PropProfAssoc}\label[prop]{prop:prof-assoc}
  We have \(\mathsf{profile} ((e; g); i) =  \mathsf{profile} (e; ( \lambda  v.~g~v; i))\).
\end{restatable}
